package models

// Code generated by dbtpl. DO NOT EDIT.

import (
	"context"
	"time"
)

// Inventory represents a row from 'public.inventory'.
type Inventory struct {
	ID               int       `json:"id"`                 // id
	ProductID        int       `json:"product_id"`         // product_id
	WarehouseID      int       `json:"warehouse_id"`       // warehouse_id
	OnHand           int       `json:"on_hand"`            // on_hand
	ReservedForOrder int       `json:"reserved_for_order"` // reserved_for_order
	Version          int64     `json:"version"`            // version
	UpdatedAt        time.Time `json:"updated_at"`         // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Inventory] exists in the database.
func (i *Inventory) Exists() bool {
	return i._exists
}

// Deleted returns true when the [Inventory] has been marked for deletion
// from the database.
func (i *Inventory) Deleted() bool {
	return i._deleted
}

// Insert inserts the [Inventory] to the database.
func (i *Inventory) Insert(ctx context.Context, db DB) error {
	switch {
	case i._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case i._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.inventory (` +
		`product_id, warehouse_id, on_hand, reserved_for_order, version, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) RETURNING id`
	// run
	logf(sqlstr, i.ProductID, i.WarehouseID, i.OnHand, i.ReservedForOrder, i.Version, i.UpdatedAt)
	if err := db.QueryRowContext(ctx, sqlstr, i.ProductID, i.WarehouseID, i.OnHand, i.ReservedForOrder, i.Version, i.UpdatedAt).Scan(&i.ID); err != nil {
		return logerror(err)
	}
	// set exists
	i._exists = true
	return nil
}

// Update updates a [Inventory] in the database.
func (i *Inventory) Update(ctx context.Context, db DB) error {
	switch {
	case !i._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case i._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.inventory SET ` +
		`product_id = $1, warehouse_id = $2, on_hand = $3, reserved_for_order = $4, version = $5, updated_at = $6 ` +
		`WHERE id = $7`
	// run
	logf(sqlstr, i.ProductID, i.WarehouseID, i.OnHand, i.ReservedForOrder, i.Version, i.UpdatedAt, i.ID)
	if _, err := db.ExecContext(ctx, sqlstr, i.ProductID, i.WarehouseID, i.OnHand, i.ReservedForOrder, i.Version, i.UpdatedAt, i.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Inventory] to the database.
func (i *Inventory) Save(ctx context.Context, db DB) error {
	if i.Exists() {
		return i.Update(ctx, db)
	}
	return i.Insert(ctx, db)
}

// Upsert performs an upsert for [Inventory].
func (i *Inventory) Upsert(ctx context.Context, db DB) error {
	switch {
	case i._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.inventory (` +
		`id, product_id, warehouse_id, on_hand, reserved_for_order, version, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`product_id = EXCLUDED.product_id, warehouse_id = EXCLUDED.warehouse_id, on_hand = EXCLUDED.on_hand, reserved_for_order = EXCLUDED.reserved_for_order, version = EXCLUDED.version, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, i.ID, i.ProductID, i.WarehouseID, i.OnHand, i.ReservedForOrder, i.Version, i.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, i.ID, i.ProductID, i.WarehouseID, i.OnHand, i.ReservedForOrder, i.Version, i.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	i._exists = true
	return nil
}

// Delete deletes the [Inventory] from the database.
func (i *Inventory) Delete(ctx context.Context, db DB) error {
	switch {
	case !i._exists: // doesn't exist
		return nil
	case i._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.inventory ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, i.ID)
	if _, err := db.ExecContext(ctx, sqlstr, i.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	i._deleted = true
	return nil
}

// InventoryByProductID retrieves a row from 'public.inventory' as a [Inventory].
//
// Generated from index 'idx_inventory_product'.
func InventoryByProductID(ctx context.Context, db DB, productID int) ([]*Inventory, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, product_id, warehouse_id, on_hand, reserved_for_order, version, updated_at ` +
		`FROM public.inventory ` +
		`WHERE product_id = $1`
	// run
	logf(sqlstr, productID)
	rows, err := db.QueryContext(ctx, sqlstr, productID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Inventory
	for rows.Next() {
		i := Inventory{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&i.ID, &i.ProductID, &i.WarehouseID, &i.OnHand, &i.ReservedForOrder, &i.Version, &i.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// InventoryByWarehouseID retrieves a row from 'public.inventory' as a [Inventory].
//
// Generated from index 'idx_inventory_warehouse'.
func InventoryByWarehouseID(ctx context.Context, db DB, warehouseID int) ([]*Inventory, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, product_id, warehouse_id, on_hand, reserved_for_order, version, updated_at ` +
		`FROM public.inventory ` +
		`WHERE warehouse_id = $1`
	// run
	logf(sqlstr, warehouseID)
	rows, err := db.QueryContext(ctx, sqlstr, warehouseID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Inventory
	for rows.Next() {
		i := Inventory{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&i.ID, &i.ProductID, &i.WarehouseID, &i.OnHand, &i.ReservedForOrder, &i.Version, &i.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// InventoryByID retrieves a row from 'public.inventory' as a [Inventory].
//
// Generated from index 'inventory_pkey'.
func InventoryByID(ctx context.Context, db DB, id int) (*Inventory, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, product_id, warehouse_id, on_hand, reserved_for_order, version, updated_at ` +
		`FROM public.inventory ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	i := Inventory{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&i.ID, &i.ProductID, &i.WarehouseID, &i.OnHand, &i.ReservedForOrder, &i.Version, &i.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &i, nil
}

// InventoryByProductIDWarehouseID retrieves a row from 'public.inventory' as a [Inventory].
//
// Generated from index 'inventory_product_id_warehouse_id_key'.
func InventoryByProductIDWarehouseID(ctx context.Context, db DB, productID, warehouseID int) (*Inventory, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, product_id, warehouse_id, on_hand, reserved_for_order, version, updated_at ` +
		`FROM public.inventory ` +
		`WHERE product_id = $1 AND warehouse_id = $2`
	// run
	logf(sqlstr, productID, warehouseID)
	i := Inventory{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, productID, warehouseID).Scan(&i.ID, &i.ProductID, &i.WarehouseID, &i.OnHand, &i.ReservedForOrder, &i.Version, &i.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &i, nil
}
