package models

// Code generated by dbtpl. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// Product represents a row from 'public.products'.
type Product struct {
	ID                 int                   `json:"id"`                   // id
	DjjCode            string                `json:"djj_code"`             // djj_code
	NameCn             string                `json:"name_cn"`              // name_cn
	NameEn             sql.NullString        `json:"name_en"`              // name_en
	Manufacturer       sql.NullString        `json:"manufacturer"`         // manufacturer
	ManufacturerCode   sql.NullString        `json:"manufacturer_code"`    // manufacturer_code
	Supplier           sql.NullString        `json:"supplier"`             // supplier
	Model              sql.NullString        `json:"model"`                // model
	CategoryID         sql.NullInt64         `json:"category_id"`          // category_id
	SubcategoryID      sql.NullInt64         `json:"subcategory_id"`       // subcategory_id
	TertiaryCategoryID sql.NullInt64         `json:"tertiary_category_id"` // tertiary_category_id
	TechnicalSpecs     []byte                `json:"technical_specs"`      // technical_specs
	Specs              sql.NullString        `json:"specs"`                // specs
	Price              float64               `json:"price"`                // price
	RrpPrice           sql.NullFloat64       `json:"rrp_price"`            // rrp_price
	Currency           CurrencyCodeEnum      `json:"currency"`             // currency
	Status             ProductStatusEnum     `json:"status"`               // status
	ApplicationStatus  ApplicationStatusEnum `json:"application_status"`   // application_status
	ProductType        ProductTypeEnum       `json:"product_type"`         // product_type
	StandardWarranty   sql.NullString        `json:"standard_warranty"`    // standard_warranty
	Remarks            sql.NullString        `json:"remarks"`              // remarks
	MarketingInfo      sql.NullString        `json:"marketing_info"`       // marketing_info
	TrainingDocs       sql.NullString        `json:"training_docs"`        // training_docs
	WeightKg           sql.NullFloat64       `json:"weight_kg"`            // weight_kg
	LiftCapacityKg     sql.NullFloat64       `json:"lift_capacity_kg"`     // lift_capacity_kg
	LiftHeightMm       sql.NullFloat64       `json:"lift_height_mm"`       // lift_height_mm
	PowerSource        sql.NullString        `json:"power_source"`         // power_source
	OtherSpecs         []byte                `json:"other_specs"`          // other_specs
	ExtraInfo          []byte                `json:"extra_info"`           // extra_info
	Metadata           []byte                `json:"metadata"`             // metadata
	Version            int64                 `json:"version"`              // version
	CreatedAt          time.Time             `json:"created_at"`           // created_at
	UpdatedAt          time.Time             `json:"updated_at"`           // updated_at
	IsDeleted          bool                  `json:"is_deleted"`           // is_deleted
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Product] exists in the database.
func (p *Product) Exists() bool {
	return p._exists
}

// Deleted returns true when the [Product] has been marked for deletion
// from the database.
func (p *Product) Deleted() bool {
	return p._deleted
}

// Insert inserts the [Product] to the database.
func (p *Product) Insert(ctx context.Context, db DB) error {
	switch {
	case p._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case p._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.products (` +
		`djj_code, name_cn, name_en, manufacturer, manufacturer_code, supplier, model, category_id, subcategory_id, tertiary_category_id, technical_specs, specs, price, rrp_price, currency, status, application_status, product_type, standard_warranty, remarks, marketing_info, training_docs, weight_kg, lift_capacity_kg, lift_height_mm, power_source, other_specs, extra_info, metadata, version, created_at, updated_at, is_deleted` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33` +
		`) RETURNING id`
	// run
	logf(sqlstr, p.DjjCode, p.NameCn, p.NameEn, p.Manufacturer, p.ManufacturerCode, p.Supplier, p.Model, p.CategoryID, p.SubcategoryID, p.TertiaryCategoryID, p.TechnicalSpecs, p.Specs, p.Price, p.RrpPrice, p.Currency, p.Status, p.ApplicationStatus, p.ProductType, p.StandardWarranty, p.Remarks, p.MarketingInfo, p.TrainingDocs, p.WeightKg, p.LiftCapacityKg, p.LiftHeightMm, p.PowerSource, p.OtherSpecs, p.ExtraInfo, p.Metadata, p.Version, p.CreatedAt, p.UpdatedAt, p.IsDeleted)
	if err := db.QueryRowContext(ctx, sqlstr, p.DjjCode, p.NameCn, p.NameEn, p.Manufacturer, p.ManufacturerCode, p.Supplier, p.Model, p.CategoryID, p.SubcategoryID, p.TertiaryCategoryID, p.TechnicalSpecs, p.Specs, p.Price, p.RrpPrice, p.Currency, p.Status, p.ApplicationStatus, p.ProductType, p.StandardWarranty, p.Remarks, p.MarketingInfo, p.TrainingDocs, p.WeightKg, p.LiftCapacityKg, p.LiftHeightMm, p.PowerSource, p.OtherSpecs, p.ExtraInfo, p.Metadata, p.Version, p.CreatedAt, p.UpdatedAt, p.IsDeleted).Scan(&p.ID); err != nil {
		return logerror(err)
	}
	// set exists
	p._exists = true
	return nil
}

// Update updates a [Product] in the database.
func (p *Product) Update(ctx context.Context, db DB) error {
	switch {
	case !p._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case p._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.products SET ` +
		`djj_code = $1, name_cn = $2, name_en = $3, manufacturer = $4, manufacturer_code = $5, supplier = $6, model = $7, category_id = $8, subcategory_id = $9, tertiary_category_id = $10, technical_specs = $11, specs = $12, price = $13, rrp_price = $14, currency = $15, status = $16, application_status = $17, product_type = $18, standard_warranty = $19, remarks = $20, marketing_info = $21, training_docs = $22, weight_kg = $23, lift_capacity_kg = $24, lift_height_mm = $25, power_source = $26, other_specs = $27, extra_info = $28, metadata = $29, version = $30, created_at = $31, updated_at = $32, is_deleted = $33 ` +
		`WHERE id = $34`
	// run
	logf(sqlstr, p.DjjCode, p.NameCn, p.NameEn, p.Manufacturer, p.ManufacturerCode, p.Supplier, p.Model, p.CategoryID, p.SubcategoryID, p.TertiaryCategoryID, p.TechnicalSpecs, p.Specs, p.Price, p.RrpPrice, p.Currency, p.Status, p.ApplicationStatus, p.ProductType, p.StandardWarranty, p.Remarks, p.MarketingInfo, p.TrainingDocs, p.WeightKg, p.LiftCapacityKg, p.LiftHeightMm, p.PowerSource, p.OtherSpecs, p.ExtraInfo, p.Metadata, p.Version, p.CreatedAt, p.UpdatedAt, p.IsDeleted, p.ID)
	if _, err := db.ExecContext(ctx, sqlstr, p.DjjCode, p.NameCn, p.NameEn, p.Manufacturer, p.ManufacturerCode, p.Supplier, p.Model, p.CategoryID, p.SubcategoryID, p.TertiaryCategoryID, p.TechnicalSpecs, p.Specs, p.Price, p.RrpPrice, p.Currency, p.Status, p.ApplicationStatus, p.ProductType, p.StandardWarranty, p.Remarks, p.MarketingInfo, p.TrainingDocs, p.WeightKg, p.LiftCapacityKg, p.LiftHeightMm, p.PowerSource, p.OtherSpecs, p.ExtraInfo, p.Metadata, p.Version, p.CreatedAt, p.UpdatedAt, p.IsDeleted, p.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Product] to the database.
func (p *Product) Save(ctx context.Context, db DB) error {
	if p.Exists() {
		return p.Update(ctx, db)
	}
	return p.Insert(ctx, db)
}

// Upsert performs an upsert for [Product].
func (p *Product) Upsert(ctx context.Context, db DB) error {
	switch {
	case p._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.products (` +
		`id, djj_code, name_cn, name_en, manufacturer, manufacturer_code, supplier, model, category_id, subcategory_id, tertiary_category_id, technical_specs, specs, price, rrp_price, currency, status, application_status, product_type, standard_warranty, remarks, marketing_info, training_docs, weight_kg, lift_capacity_kg, lift_height_mm, power_source, other_specs, extra_info, metadata, version, created_at, updated_at, is_deleted` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`djj_code = EXCLUDED.djj_code, name_cn = EXCLUDED.name_cn, name_en = EXCLUDED.name_en, manufacturer = EXCLUDED.manufacturer, manufacturer_code = EXCLUDED.manufacturer_code, supplier = EXCLUDED.supplier, model = EXCLUDED.model, category_id = EXCLUDED.category_id, subcategory_id = EXCLUDED.subcategory_id, tertiary_category_id = EXCLUDED.tertiary_category_id, technical_specs = EXCLUDED.technical_specs, specs = EXCLUDED.specs, price = EXCLUDED.price, rrp_price = EXCLUDED.rrp_price, currency = EXCLUDED.currency, status = EXCLUDED.status, application_status = EXCLUDED.application_status, product_type = EXCLUDED.product_type, standard_warranty = EXCLUDED.standard_warranty, remarks = EXCLUDED.remarks, marketing_info = EXCLUDED.marketing_info, training_docs = EXCLUDED.training_docs, weight_kg = EXCLUDED.weight_kg, lift_capacity_kg = EXCLUDED.lift_capacity_kg, lift_height_mm = EXCLUDED.lift_height_mm, power_source = EXCLUDED.power_source, other_specs = EXCLUDED.other_specs, extra_info = EXCLUDED.extra_info, metadata = EXCLUDED.metadata, version = EXCLUDED.version, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at, is_deleted = EXCLUDED.is_deleted `
	// run
	logf(sqlstr, p.ID, p.DjjCode, p.NameCn, p.NameEn, p.Manufacturer, p.ManufacturerCode, p.Supplier, p.Model, p.CategoryID, p.SubcategoryID, p.TertiaryCategoryID, p.TechnicalSpecs, p.Specs, p.Price, p.RrpPrice, p.Currency, p.Status, p.ApplicationStatus, p.ProductType, p.StandardWarranty, p.Remarks, p.MarketingInfo, p.TrainingDocs, p.WeightKg, p.LiftCapacityKg, p.LiftHeightMm, p.PowerSource, p.OtherSpecs, p.ExtraInfo, p.Metadata, p.Version, p.CreatedAt, p.UpdatedAt, p.IsDeleted)
	if _, err := db.ExecContext(ctx, sqlstr, p.ID, p.DjjCode, p.NameCn, p.NameEn, p.Manufacturer, p.ManufacturerCode, p.Supplier, p.Model, p.CategoryID, p.SubcategoryID, p.TertiaryCategoryID, p.TechnicalSpecs, p.Specs, p.Price, p.RrpPrice, p.Currency, p.Status, p.ApplicationStatus, p.ProductType, p.StandardWarranty, p.Remarks, p.MarketingInfo, p.TrainingDocs, p.WeightKg, p.LiftCapacityKg, p.LiftHeightMm, p.PowerSource, p.OtherSpecs, p.ExtraInfo, p.Metadata, p.Version, p.CreatedAt, p.UpdatedAt, p.IsDeleted); err != nil {
		return logerror(err)
	}
	// set exists
	p._exists = true
	return nil
}

// Delete deletes the [Product] from the database.
func (p *Product) Delete(ctx context.Context, db DB) error {
	switch {
	case !p._exists: // doesn't exist
		return nil
	case p._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.products ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, p.ID)
	if _, err := db.ExecContext(ctx, sqlstr, p.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	p._deleted = true
	return nil
}

// ProductsByCategoryID retrieves a row from 'public.products' as a [Product].
//
// Generated from index 'idx_products_category'.
func ProductsByCategoryID(ctx context.Context, db DB, categoryID sql.NullInt64) ([]*Product, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, djj_code, name_cn, name_en, manufacturer, manufacturer_code, supplier, model, category_id, subcategory_id, tertiary_category_id, technical_specs, specs, price, rrp_price, currency, status, application_status, product_type, standard_warranty, remarks, marketing_info, training_docs, weight_kg, lift_capacity_kg, lift_height_mm, power_source, other_specs, extra_info, metadata, version, created_at, updated_at, is_deleted ` +
		`FROM public.products ` +
		`WHERE category_id = $1`
	// run
	logf(sqlstr, categoryID)
	rows, err := db.QueryContext(ctx, sqlstr, categoryID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Product
	for rows.Next() {
		p := Product{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&p.ID, &p.DjjCode, &p.NameCn, &p.NameEn, &p.Manufacturer, &p.ManufacturerCode, &p.Supplier, &p.Model, &p.CategoryID, &p.SubcategoryID, &p.TertiaryCategoryID, &p.TechnicalSpecs, &p.Specs, &p.Price, &p.RrpPrice, &p.Currency, &p.Status, &p.ApplicationStatus, &p.ProductType, &p.StandardWarranty, &p.Remarks, &p.MarketingInfo, &p.TrainingDocs, &p.WeightKg, &p.LiftCapacityKg, &p.LiftHeightMm, &p.PowerSource, &p.OtherSpecs, &p.ExtraInfo, &p.Metadata, &p.Version, &p.CreatedAt, &p.UpdatedAt, &p.IsDeleted); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &p)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// ProductsByRrpPrice retrieves a row from 'public.products' as a [Product].
//
// Generated from index 'idx_products_rrp_price'.
func ProductsByRrpPrice(ctx context.Context, db DB, rrpPrice sql.NullFloat64) ([]*Product, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, djj_code, name_cn, name_en, manufacturer, manufacturer_code, supplier, model, category_id, subcategory_id, tertiary_category_id, technical_specs, specs, price, rrp_price, currency, status, application_status, product_type, standard_warranty, remarks, marketing_info, training_docs, weight_kg, lift_capacity_kg, lift_height_mm, power_source, other_specs, extra_info, metadata, version, created_at, updated_at, is_deleted ` +
		`FROM public.products ` +
		`WHERE rrp_price = $1`
	// run
	logf(sqlstr, rrpPrice)
	rows, err := db.QueryContext(ctx, sqlstr, rrpPrice)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Product
	for rows.Next() {
		p := Product{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&p.ID, &p.DjjCode, &p.NameCn, &p.NameEn, &p.Manufacturer, &p.ManufacturerCode, &p.Supplier, &p.Model, &p.CategoryID, &p.SubcategoryID, &p.TertiaryCategoryID, &p.TechnicalSpecs, &p.Specs, &p.Price, &p.RrpPrice, &p.Currency, &p.Status, &p.ApplicationStatus, &p.ProductType, &p.StandardWarranty, &p.Remarks, &p.MarketingInfo, &p.TrainingDocs, &p.WeightKg, &p.LiftCapacityKg, &p.LiftHeightMm, &p.PowerSource, &p.OtherSpecs, &p.ExtraInfo, &p.Metadata, &p.Version, &p.CreatedAt, &p.UpdatedAt, &p.IsDeleted); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &p)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// ProductsBySupplier retrieves a row from 'public.products' as a [Product].
//
// Generated from index 'idx_products_supplier'.
func ProductsBySupplier(ctx context.Context, db DB, supplier sql.NullString) ([]*Product, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, djj_code, name_cn, name_en, manufacturer, manufacturer_code, supplier, model, category_id, subcategory_id, tertiary_category_id, technical_specs, specs, price, rrp_price, currency, status, application_status, product_type, standard_warranty, remarks, marketing_info, training_docs, weight_kg, lift_capacity_kg, lift_height_mm, power_source, other_specs, extra_info, metadata, version, created_at, updated_at, is_deleted ` +
		`FROM public.products ` +
		`WHERE supplier = $1`
	// run
	logf(sqlstr, supplier)
	rows, err := db.QueryContext(ctx, sqlstr, supplier)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Product
	for rows.Next() {
		p := Product{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&p.ID, &p.DjjCode, &p.NameCn, &p.NameEn, &p.Manufacturer, &p.ManufacturerCode, &p.Supplier, &p.Model, &p.CategoryID, &p.SubcategoryID, &p.TertiaryCategoryID, &p.TechnicalSpecs, &p.Specs, &p.Price, &p.RrpPrice, &p.Currency, &p.Status, &p.ApplicationStatus, &p.ProductType, &p.StandardWarranty, &p.Remarks, &p.MarketingInfo, &p.TrainingDocs, &p.WeightKg, &p.LiftCapacityKg, &p.LiftHeightMm, &p.PowerSource, &p.OtherSpecs, &p.ExtraInfo, &p.Metadata, &p.Version, &p.CreatedAt, &p.UpdatedAt, &p.IsDeleted); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &p)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// ProductByDjjCode retrieves a row from 'public.products' as a [Product].
//
// Generated from index 'products_djj_code_key'.
func ProductByDjjCode(ctx context.Context, db DB, djjCode string) (*Product, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, djj_code, name_cn, name_en, manufacturer, manufacturer_code, supplier, model, category_id, subcategory_id, tertiary_category_id, technical_specs, specs, price, rrp_price, currency, status, application_status, product_type, standard_warranty, remarks, marketing_info, training_docs, weight_kg, lift_capacity_kg, lift_height_mm, power_source, other_specs, extra_info, metadata, version, created_at, updated_at, is_deleted ` +
		`FROM public.products ` +
		`WHERE djj_code = $1`
	// run
	logf(sqlstr, djjCode)
	p := Product{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, djjCode).Scan(&p.ID, &p.DjjCode, &p.NameCn, &p.NameEn, &p.Manufacturer, &p.ManufacturerCode, &p.Supplier, &p.Model, &p.CategoryID, &p.SubcategoryID, &p.TertiaryCategoryID, &p.TechnicalSpecs, &p.Specs, &p.Price, &p.RrpPrice, &p.Currency, &p.Status, &p.ApplicationStatus, &p.ProductType, &p.StandardWarranty, &p.Remarks, &p.MarketingInfo, &p.TrainingDocs, &p.WeightKg, &p.LiftCapacityKg, &p.LiftHeightMm, &p.PowerSource, &p.OtherSpecs, &p.ExtraInfo, &p.Metadata, &p.Version, &p.CreatedAt, &p.UpdatedAt, &p.IsDeleted); err != nil {
		return nil, logerror(err)
	}
	return &p, nil
}

// ProductByID retrieves a row from 'public.products' as a [Product].
//
// Generated from index 'products_pkey'.
func ProductByID(ctx context.Context, db DB, id int) (*Product, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, djj_code, name_cn, name_en, manufacturer, manufacturer_code, supplier, model, category_id, subcategory_id, tertiary_category_id, technical_specs, specs, price, rrp_price, currency, status, application_status, product_type, standard_warranty, remarks, marketing_info, training_docs, weight_kg, lift_capacity_kg, lift_height_mm, power_source, other_specs, extra_info, metadata, version, created_at, updated_at, is_deleted ` +
		`FROM public.products ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	p := Product{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&p.ID, &p.DjjCode, &p.NameCn, &p.NameEn, &p.Manufacturer, &p.ManufacturerCode, &p.Supplier, &p.Model, &p.CategoryID, &p.SubcategoryID, &p.TertiaryCategoryID, &p.TechnicalSpecs, &p.Specs, &p.Price, &p.RrpPrice, &p.Currency, &p.Status, &p.ApplicationStatus, &p.ProductType, &p.StandardWarranty, &p.Remarks, &p.MarketingInfo, &p.TrainingDocs, &p.WeightKg, &p.LiftCapacityKg, &p.LiftHeightMm, &p.PowerSource, &p.OtherSpecs, &p.ExtraInfo, &p.Metadata, &p.Version, &p.CreatedAt, &p.UpdatedAt, &p.IsDeleted); err != nil {
		return nil, logerror(err)
	}
	return &p, nil
}
