package models

// Code generated by dbtpl. DO NOT EDIT.

import (
	"database/sql/driver"
	"fmt"
)

// ProductStatusEnum is the 'product_status_enum' enum type from schema 'public'.
type ProductStatusEnum uint16

// ProductStatusEnum values.
const (
	// ProductStatusEnumDraft is the 'draft' product_status_enum.
	ProductStatusEnumDraft ProductStatusEnum = 1
	// ProductStatusEnumPendingTech is the 'pending_tech' product_status_enum.
	ProductStatusEnumPendingTech ProductStatusEnum = 2
	// ProductStatusEnumPendingPurchase is the 'pending_purchase' product_status_enum.
	ProductStatusEnumPendingPurchase ProductStatusEnum = 3
	// ProductStatusEnumPendingFinance is the 'pending_finance' product_status_enum.
	ProductStatusEnumPendingFinance ProductStatusEnum = 4
	// ProductStatusEnumReadyPublished is the 'ready_published' product_status_enum.
	ProductStatusEnumReadyPublished ProductStatusEnum = 5
	// ProductStatusEnumPublished is the 'published' product_status_enum.
	ProductStatusEnumPublished ProductStatusEnum = 6
	// ProductStatusEnumRejected is the 'rejected' product_status_enum.
	ProductStatusEnumRejected ProductStatusEnum = 7
	// ProductStatusEnumClosed is the 'closed' product_status_enum.
	ProductStatusEnumClosed ProductStatusEnum = 8
)

// String satisfies the [fmt.Stringer] interface.
func (pse ProductStatusEnum) String() string {
	switch pse {
	case ProductStatusEnumDraft:
		return "draft"
	case ProductStatusEnumPendingTech:
		return "pending_tech"
	case ProductStatusEnumPendingPurchase:
		return "pending_purchase"
	case ProductStatusEnumPendingFinance:
		return "pending_finance"
	case ProductStatusEnumReadyPublished:
		return "ready_published"
	case ProductStatusEnumPublished:
		return "published"
	case ProductStatusEnumRejected:
		return "rejected"
	case ProductStatusEnumClosed:
		return "closed"
	}
	return fmt.Sprintf("ProductStatusEnum(%d)", pse)
}

// MarshalText marshals [ProductStatusEnum] into text.
func (pse ProductStatusEnum) MarshalText() ([]byte, error) {
	return []byte(pse.String()), nil
}

// UnmarshalText unmarshals [ProductStatusEnum] from text.
func (pse *ProductStatusEnum) UnmarshalText(buf []byte) error {
	switch str := string(buf); str {
	case "draft":
		*pse = ProductStatusEnumDraft
	case "pending_tech":
		*pse = ProductStatusEnumPendingTech
	case "pending_purchase":
		*pse = ProductStatusEnumPendingPurchase
	case "pending_finance":
		*pse = ProductStatusEnumPendingFinance
	case "ready_published":
		*pse = ProductStatusEnumReadyPublished
	case "published":
		*pse = ProductStatusEnumPublished
	case "rejected":
		*pse = ProductStatusEnumRejected
	case "closed":
		*pse = ProductStatusEnumClosed
	default:
		return ErrInvalidProductStatusEnum(str)
	}
	return nil
}

// Value satisfies the [driver.Valuer] interface.
func (pse ProductStatusEnum) Value() (driver.Value, error) {
	return pse.String(), nil
}

// Scan satisfies the [sql.Scanner] interface.
func (pse *ProductStatusEnum) Scan(v any) error {
	switch x := v.(type) {
	case []byte:
		return pse.UnmarshalText(x)
	case string:
		return pse.UnmarshalText([]byte(x))
	}
	return ErrInvalidProductStatusEnum(fmt.Sprintf("%T", v))
}

// NullProductStatusEnum represents a null 'product_status_enum' enum for schema 'public'.
type NullProductStatusEnum struct {
	ProductStatusEnum ProductStatusEnum
	// Valid is true if [ProductStatusEnum] is not null.
	Valid bool
}

// Value satisfies the [driver.Valuer] interface.
func (npse NullProductStatusEnum) Value() (driver.Value, error) {
	if !npse.Valid {
		return nil, nil
	}
	return npse.ProductStatusEnum.Value()
}

// Scan satisfies the [sql.Scanner] interface.
func (npse *NullProductStatusEnum) Scan(v any) error {
	if v == nil {
		npse.ProductStatusEnum, npse.Valid = 0, false
		return nil
	}
	err := npse.ProductStatusEnum.Scan(v)
	npse.Valid = err == nil
	return err
}

// ErrInvalidProductStatusEnum is the invalid [ProductStatusEnum] error.
type ErrInvalidProductStatusEnum string

// Error satisfies the error interface.
func (err ErrInvalidProductStatusEnum) Error() string {
	return fmt.Sprintf("invalid ProductStatusEnum(%s)", string(err))
}
