package models

// Code generated by dbtpl. DO NOT EDIT.

import (
	"database/sql/driver"
	"fmt"
)

// ProductTypeEnum is the 'product_type_enum' enum type from schema 'public'.
type ProductTypeEnum uint16

// ProductTypeEnum values.
const (
	// ProductTypeEnumMachine is the 'machine' product_type_enum.
	ProductTypeEnumMachine ProductTypeEnum = 1
	// ProductTypeEnumParts is the 'parts' product_type_enum.
	ProductTypeEnumParts ProductTypeEnum = 2
	// ProductTypeEnumAttachment is the 'attachment' product_type_enum.
	ProductTypeEnumAttachment ProductTypeEnum = 3
	// ProductTypeEnumTools is the 'tools' product_type_enum.
	ProductTypeEnumTools ProductTypeEnum = 4
	// ProductTypeEnumOthers is the 'others' product_type_enum.
	ProductTypeEnumOthers ProductTypeEnum = 5
)

// String satisfies the [fmt.Stringer] interface.
func (pte ProductTypeEnum) String() string {
	switch pte {
	case ProductTypeEnumMachine:
		return "machine"
	case ProductTypeEnumParts:
		return "parts"
	case ProductTypeEnumAttachment:
		return "attachment"
	case ProductTypeEnumTools:
		return "tools"
	case ProductTypeEnumOthers:
		return "others"
	}
	return fmt.Sprintf("ProductTypeEnum(%d)", pte)
}

// MarshalText marshals [ProductTypeEnum] into text.
func (pte ProductTypeEnum) MarshalText() ([]byte, error) {
	return []byte(pte.String()), nil
}

// UnmarshalText unmarshals [ProductTypeEnum] from text.
func (pte *ProductTypeEnum) UnmarshalText(buf []byte) error {
	switch str := string(buf); str {
	case "machine":
		*pte = ProductTypeEnumMachine
	case "parts":
		*pte = ProductTypeEnumParts
	case "attachment":
		*pte = ProductTypeEnumAttachment
	case "tools":
		*pte = ProductTypeEnumTools
	case "others":
		*pte = ProductTypeEnumOthers
	default:
		return ErrInvalidProductTypeEnum(str)
	}
	return nil
}

// Value satisfies the [driver.Valuer] interface.
func (pte ProductTypeEnum) Value() (driver.Value, error) {
	return pte.String(), nil
}

// Scan satisfies the [sql.Scanner] interface.
func (pte *ProductTypeEnum) Scan(v any) error {
	switch x := v.(type) {
	case []byte:
		return pte.UnmarshalText(x)
	case string:
		return pte.UnmarshalText([]byte(x))
	}
	return ErrInvalidProductTypeEnum(fmt.Sprintf("%T", v))
}

// NullProductTypeEnum represents a null 'product_type_enum' enum for schema 'public'.
type NullProductTypeEnum struct {
	ProductTypeEnum ProductTypeEnum
	// Valid is true if [ProductTypeEnum] is not null.
	Valid bool
}

// Value satisfies the [driver.Valuer] interface.
func (npte NullProductTypeEnum) Value() (driver.Value, error) {
	if !npte.Valid {
		return nil, nil
	}
	return npte.ProductTypeEnum.Value()
}

// Scan satisfies the [sql.Scanner] interface.
func (npte *NullProductTypeEnum) Scan(v any) error {
	if v == nil {
		npte.ProductTypeEnum, npte.Valid = 0, false
		return nil
	}
	err := npte.ProductTypeEnum.Scan(v)
	npte.Valid = err == nil
	return err
}

// ErrInvalidProductTypeEnum is the invalid [ProductTypeEnum] error.
type ErrInvalidProductTypeEnum string

// Error satisfies the error interface.
func (err ErrInvalidProductTypeEnum) Error() string {
	return fmt.Sprintf("invalid ProductTypeEnum(%s)", string(err))
}
